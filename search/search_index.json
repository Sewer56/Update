{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#about-update","title":"About Update","text":"<p><code>Update</code> is a lightweight-ish updating framework for .NET applications. </p> <p>It is designed with the purpose of updating arbitrary things, including but not limited to: - Current Application - Plugins - Modules  </p> <p>The goal of this library is to be extensible; allowing users to easily add support for their own components such as download sources and compression formats without requiring changes to the library code.</p> <p>Update is heavily inspired by Onova by Alexey Golub and has a somewhat similar API. <code>Update</code> in particular adds additional features such as delta compression at the expense of a slightly more complex configuration process.</p>"},{"location":"#when-to-use-update","title":"When to use Update","text":"<ul> <li>You ship very big updates and require delta compression support between versions.</li> <li>You want to clean up your application folder after updates.</li> <li>You want to update things other than just the application you are running.</li> <li>You need to support Semantic Versioning (and thus Prereleases).</li> </ul>"},{"location":"#when-to-not-use-update","title":"When to not use Update","text":"<p>Consider using the original Onova (or another library) if you have any of the following requirements:</p> <ul> <li>If you wish to use this library with .NET Framework (VCDiff needs backported).</li> <li>You need a simpler CI/CD deployment &amp; integration experience.</li> <li>You can only upload 1 file to a given website.</li> </ul>"},{"location":"#how-the-library-works-summary","title":"How the Library Works (Summary)","text":""},{"location":"#releases","title":"Releases","text":"<p>You create releases using either the pre-included tool (<code>Sewer56.Update.Tool</code>) or from your own program via the API.</p> <p>Releases are composed of archives for every version included in the release and a manifest, storing metadata for these archives (e.g. Versions).</p>"},{"location":"#download-routine","title":"Download Routine","text":"<p>When you check for updates, the release manifest is downloaded from your specified source and the list of available versions is returned to you. When you download a specific version, the library gets the update file name from the manifest and downloads it from your specified source.</p>"},{"location":"#post-extraction-routine","title":"Post Extraction Routine","text":"<ul> <li>If simple update: Files are copied and overwritten.</li> <li>If delta update: VCDiff based delta patching happens.</li> </ul> <p>After the update is complete, a <code>package manifest</code> file is used (if available) to verify the new files are correct and remove any extra redundant files. </p>"},{"location":"#in-process-out-of-process","title":"In Process &amp; Out of Process","text":"<p>If the data to be updated is something other than the current application, everything is done inside your current application.</p> <p>If the data to be updated is the current application itself, the library runs an instance of the application, which performs the steps outlined in <code>Post Extraction Routine</code>.</p>"},{"location":"#cross-platform-support","title":"Cross Platform Support","text":"<p><code>Update</code> should in theory function on any platform that supports <code>CoreCLR</code> (.NET Core Runtime) providing the following criteria are met:</p> <ul> <li> <p>Either of the following: </p> <ul> <li>The .NET Core runtime is available in <code>PATH</code> (i.e. you can execute <code>dotnet</code> in a terminal).</li> <li>The application is self contained.  </li> </ul> </li> <li> <p>The folder containing the application is writable (not read only). </p> </li> </ul> <p>While I don't actively test non-Windows targets, the CI/CD builds and testing are actively ran against Ubuntu (Latest); so hopefully the library should work on other platforms.</p>"},{"location":"#etymology","title":"Etymology","text":"<p>Update is a pun on the name Onova, which is the Ukrainian word for \"update\" (noun).</p>"},{"location":"ci-cd/","title":"CI/CD","text":""},{"location":"ci-cd/#cicd-integration","title":"CI/CD Integration","text":"<p>The easiest way to integrate <code>Update</code> with CI/CD is to download the latest version when you are building a new version.  </p> <p>Refer to Release Creation on how to create a release using the CLI.  </p>"},{"location":"ci-cd/#bash","title":"Bash:","text":"<pre><code># Download Latest Release\ncurl -L -O https://github.com/Sewer56/Update/releases/latest/download/Sewer56.Update.Tool.zip\n\n# Extract Tools\nunzip Sewer56.Update.Tool.zip -d \"Update-Tools\"\n\n# To run the tool use:\ndotnet ./Update-Tools/Sewer56.Update.Tool.dll /* Arguments */\n</code></pre>"},{"location":"ci-cd/#powershell","title":"Powershell:","text":"<pre><code># Download Latest Release\nInvoke-WebRequest -Uri \"https://github.com/Sewer56/Update/releases/latest/download/Sewer56.Update.Tool.zip\" -OutFile \"Sewer56.Update.Tool.zip\"\n\n# Extract Tools\nExpand-Archive -LiteralPath './Sewer56.Update.Tool.zip' -DestinationPath \"Update-Tools\"\n\n# To run the tool use:\ndotnet ./Update-Tools/Sewer56.Update.Tool.dll /* Arguments */\n</code></pre>"},{"location":"ci-cd/#useful-use-cases","title":"Useful Use Cases","text":"<p>Warning</p> <p>Certain tool options return data to standard output (stdout). Please specify the <code>--noprogressbar</code> parameter if you wish to use those.  </p>"},{"location":"ci-cd/#downloading-previous-packages","title":"Downloading Previous Packages","text":"<p>It is possible to download existing packages by using the update tool. This may be useful in some more advanced use cases.  </p> <p>Here are some examples:  </p> <p>GitHub <pre><code>dotnet Sewer56.Update.Tool.dll DownloadPackage --outputpath \"Mod.pkg\" --source GitHub --githubusername Sewer56 --githubrepositoryname Update.Test.Repo\n</code></pre></p> <p>NuGet <pre><code>dotnet Sewer56.Update.Tool.dll DownloadPackage --outputpath \"Mod.pkg\" --source NuGet --nugetfeedurl http://packages.sewer56.moe:5000/v3/index.json --nugetpackageid reloaded.sharedlib.hooks\n</code></pre></p> <p>GameBanana <pre><code>dotnet Sewer56.Update.Tool.dll DownloadPackage --extract --outputpath \"Mod.pkg\" --source GameBanana --gamebananaitemid 333681\n</code></pre></p> <p>The version of the downloaded package is returned to standard output. So you could write the version of the downloaded package to a file using <code>dotnet Sewer56.Update.Tool.dll DownloadPackage --noprogressbar ... &gt; version.txt</code> to save it to a file called <code>version.txt</code>.</p>"},{"location":"ci-cd/#auto-creating-delta-packages","title":"Auto Creating Delta Packages","text":"<p>You can automatically download older versions of a package and create delta packages by using the <code>AutoCreateDelta</code> option.</p> <pre><code>dotnet Sewer56.Update.Tool.dll AutoCreateDelta `\n--outputpath \"DeltaPackages\" `           # Where to save generated packages.\n--folderpath \"current-version-package\" ` # Where package for current version (made with `CreateCopyPackage`) is stored.\n--version \"1.0.0\" `                      # Current version's version number.\n--source \"GitHub\" `                      # Where to get previous version from.\n--githubusername \"Reloaded-Project\" `    \n--githubrepositoryname \"Reloaded-II\" `\n--githublegacyfallbackpattern \"Release.zip\" `\n--numreleases 5 ` # Number of releases to create delta packages for.\n--noprogressbar ` # Required for safe piping to packages.txt\n&gt;&gt; packages.txt\n</code></pre> <p>This will generate delta updates and append their location to <code>packages.txt</code>, which can then be passed to <code>--existingpackagespath</code> parameter of <code>CreateRelease</code> command.</p>"},{"location":"ci-cd/#note","title":"Note","text":"<p>This article is a stub. You can help by expanding it with a pull request! I'm in docs/ci-cd.md!.</p>"},{"location":"release-creation/","title":"Creating Releases","text":""},{"location":"release-creation/#structure-of-a-release","title":"Structure of a Release","text":"<p>The following diagram shows a high level overview of the files/components involved in each release.</p> <pre><code>                      +--------------------+       +-------------------+\n                      | RELEASE MANIFEST   |       | DELTA MANIFEST    |\n                      +--------------------+       +-------------------+\n                      | A list of:         |       | Used if Package   |\n                      | - Package FileName +-------+ Type is Delta     |\n          +-----------+ - Package Version  |       +-------------------+\n          |           | - Package Type     |       | - Expected Hashes |       \n+---------+--------+  | - Target Version   |       +-------------------+\n| RELEASE          |  +--------------------+\n+------------------+\n| Release Manifest |\n| Package 1        +----+\n| Package 2        |    |\n+------------------+    |                       +------------------------+\n                      +-+-----------------+     | PACKAGE MANIFEST       |\n                      | PACKAGE           |     +------------------------+\n                      +-------------------+     | - Package Type         |\n                      | Package Manifest  +-----+ - Package Version      |\n                      | &lt;Package Files&gt;   |     | - List of Files        |\n                      +-------------------+     | - Cleanup/Ignore Regex |\n                                                | - Custom Extra Data    |\n                                                +------------------------+\n</code></pre> <p>A package contains an individual version of a program; a release is a collection of packages storing multiple versions. Packages you install, Releases you upload/publish to the web.</p>"},{"location":"release-creation/#creating-packages","title":"Creating Packages","text":"<p>For creating fully featured update packages using CLI, a separate program called <code>Sewer56.Update.Tool</code> is provided. This tool is cross-platform and should be usable from any environment if .NET Core itself is available.</p> <p>You can find the tool in the <code>releases</code> section of the official GitHub repository.  </p>"},{"location":"release-creation/#using-the-cli","title":"Using the CLI","text":"<pre><code>// Create a Copy Package (files are copied directly to destination).\ndotnet Sewer56.Update.Tool.dll CreateCopyPackage --folderpath \"Files/NewVersion\" --version \"1.0\" --outputpath \"Files/Packages/1.0\"\n\n// Create a Delta Package from Previous to New Version.\ndotnet Sewer56.Update.Tool.dll CreateDeltaPackage --folderpath \"Files/NewVersion\" --lastversionfolderpath \"Files/LastVersion\" --version \"1.0.1\" --lastversion \"1.0\" --outputpath \"Files/Packages/1.0_to_1.0.1\"\n</code></pre> <p>You can access help with e.g. <code>dotnet Sewer56.Update.Tool.dll CreateCopyPackage --help</code>.</p>"},{"location":"release-creation/#using-the-api","title":"Using the API","text":"<p>Note: You can also automatically create packages as part of the release process by using the <code>ReleaseBuilder&lt;T&gt;</code> api (see below). Only use this API if you wish to create packages without making a release.</p> <p>Consider using the <code>Package&lt;T&gt;</code> API. Example: </p> <pre><code>// Create Regular Package\nawait Package&lt;Empty&gt;.CreateAsync(PackageContentFolder, OutputFolder, \"1.0\");\n\n// Create Delta Package\nawait Package&lt;Empty&gt;.CreateDeltaAsync(LastVersionFolder, CurrentVersionFolder, OutputFolder, \"1.0\", \"1.0.1\");\n</code></pre>"},{"location":"release-creation/#creating-releases","title":"Creating Releases","text":""},{"location":"release-creation/#using-the-cli_1","title":"Using the CLI","text":"<p>Create a text file containing a list of all packages in the release (one package per line).  Each line should contain a relative or full path to the package to be included. </p> <p>Example:</p> <ul> <li> <p>Packages.txt <pre><code>Files/Packages/1.0\nFiles/Packages/1.0.1\nFiles/Packages/1.0_to_1.0.1\n</code></pre></p> </li> <li> <p>Command <pre><code>// Create a simple release, with existing packages sourced from Packages.txt\n// Output the release in `Files.release` and call the package files \"Poems\".\ndotnet Sewer56.Update.Tool.dll --existingpackagespath \"Files/Packages.txt\" --outputpath \"Files/Release\" --packagename Poems \n</code></pre></p> </li> </ul>"},{"location":"release-creation/#using-the-api_1","title":"Using the API","text":"<p>You can build a fresh release by using the <code>ReleaseBuilder&lt;T&gt;</code> API. Here is an example:</p> <pre><code>// Arrange\nvar builder = new ReleaseBuilder&lt;Empty&gt;();\nbuilder.AddCopyPackage(new CopyBuilderItem&lt;Empty&gt;()\n{\n    FolderPath = Assets.ManyFileFolderOriginal,\n    Version = \"1.0\"\n});\n\n// Act\nvar metadata = await builder.BuildAsync(new BuildArgs()\n{\n    FileName     = \"Package\",\n    OutputFolder = this.OutputFolder\n});\n</code></pre> <p>This will build a release with 1 package at <code>Assets.ManyFileFolderOriginal</code> and place the release into <code>OutputFolder</code>.</p>"},{"location":"release-creation/#support-for-legacy-releases","title":"Support for Legacy Releases","text":"<p>For legacy reasons, packages without a manifest are also supported. This is to make moving from older update systems easier; however you lose the support for automatic cleanup of leftover files from old versions.</p>"},{"location":"usage/","title":"Basic Usage","text":""},{"location":"usage/#prerequisites","title":"Prerequisites","text":""},{"location":"usage/#install-command-line-handler","title":"Install Command Line Handler","text":"<p>In your application's startup/main function, install a handler to <code>Update</code>. This handler is used for copying files over to the destination directory.</p> <pre><code>// Handles command line arguments passed to app.\nif (Startup.HandleCommandLineArgs(args))\n{\n    /* If true, cleanly exit application here */ \n}\n</code></pre> <p>Note: This is only required when performing updates on the application you are currently running <code>Update</code> from.</p>"},{"location":"usage/#basic-usage","title":"Basic Usage","text":""},{"location":"usage/#simple-example","title":"Simple Example","text":"<pre><code>// Create an update manager that updates from filesystem `LocalPackageResolver` and stores packages as zips `ZipPackageExtractor`.\nusing var manager = await UpdateManager&lt;Empty&gt;.CreateAsync(updatee, new LocalPackageResolver(\"c:\\\\test\\\\release\"), new ZipPackageExtractor());\n\n// Check for new version and, if available, perform full update to latest version.\nif (await manager.CheckPerformUpdateAsync(new OutOfProcessOptions(), progressHandler))\n{\n    /* \n        Returns true if shutting down the application is required.\n        So cleanly exit application here. \n    */\n}\n</code></pre>"},{"location":"usage/#handling-update-steps-manually","title":"Handling Update Steps Manually","text":"<p>To provide users the most optimal experience, you might probably want to handle intermediate steps manually.</p> <pre><code>var result = await manager.CheckForUpdatesAsync();\nif (result.CanUpdate)\n{\n    // Downloads and extracts the package in the background\n    // (supports progress reporting and cancellation)\n    await manager.PrepareUpdateAsync(result.LastVersion);\n\n    // Launch an executable that will apply the update\n    // (can be instructed to restart the application afterwards)\n    if (await manager.StartUpdateAsync(result.LastVersion, outOfProcessOptions)) \n    {\n        /* \n            Returns true if shutting down the application is required.\n            So cleanly exit application here. \n        */\n    }\n}\n</code></pre>"},{"location":"usage/#appendix","title":"Appendix","text":"<p>If you are curious about the purpose of <code>Empty</code> generic item, refer to Extra Package Metadata.</p>"},{"location":"archivers/nuget/","title":"NuGet","text":""},{"location":"archivers/nuget/#nuget-package-archiver","title":"NuGet Package Archiver","text":"<p>[Found In: <code>Sewer56.Update.Resolvers.NuGet</code>]  </p> <p>The <code>NuGet Package Archiver</code> can be used to extract or archive NuGet compatible packages with the <code>.nupkg</code> extension.</p>"},{"location":"archivers/nuget/#example-usage-extract","title":"Example Usage (Extract)","text":"<pre><code>// Example: In the UpdateManager API.\nawait UpdateManager&lt;Empty&gt;.CreateAsync(dummyUpdatee, new LocalPackageResolver(this.OutputFolder), new NuGetPackageExtractor());\n</code></pre>"},{"location":"archivers/nuget/#example-usage-compress","title":"Example Usage (Compress)","text":"<p>Note: This is the default archiver and will be used if none is specified.</p> <pre><code>// Example: In the ReleaseBuilder API.\n// builder == ReleaseBuilder\nvar metadata = await builder.BuildAsync(new BuildArgs()\n{\n    FileName = \"Package\",\n    OutputFolder = this.OutputFolder,\n    PackageArchiver = new new NuGetPackageArchiverSettings()\n    {\n        Id = \"NuGet.Package\", // &lt;======= Fill in Required NuSpec components\n        Authors = new List&lt;string&gt;() { \"Sewer56\" },\n        Description = \"No\"\n    })\n}\n</code></pre>"},{"location":"archivers/nuget/#about-this-implementation","title":"About this Implementation","text":"<p>This implementation by default packs files in <code>contentFiles/any/Sewer56.Update</code>.  This is to roughly match the structure of a real <code>NuGet</code> package.</p> <p>If the expected directory does not exist, the whole package is extracted instead.</p>"},{"location":"archivers/sevenzipsharp/","title":"SevenZipSharp","text":""},{"location":"archivers/sevenzipsharp/#sevenzipsharp-archiver","title":"SevenZipSharp Archiver","text":"<p>[Warning: Windows Only] [Found In: <code>Sewer56.Update.Extractors.SevenZipSharp</code>]  </p> <p>The <code>SevenZipSharp Archiver</code> is based on Squid Box's fork of SevenZipSharp, a wrapper for the native <code>7z.dll</code> on Windows.</p> <p>The implementation is actively tested with the following containers: - Zip - 7z  </p> <p>And the following compression formats: - Deflate - Deflate64 - LZMA - LZMA2  - PPMd  </p> <p>Other formats supported by the library should however still work.</p>"},{"location":"archivers/sevenzipsharp/#example-usage-extract","title":"Example Usage (Extract)","text":"<pre><code>// Example: In the UpdateManager API.\nawait UpdateManager&lt;Empty&gt;.CreateAsync(dummyUpdatee, new LocalPackageResolver(this.OutputFolder), new SevenZipSharpExtractor());\n</code></pre>"},{"location":"archivers/sevenzipsharp/#example-usage-compress","title":"Example Usage (Compress)","text":"<p>Note: This is the default archiver and will be used if none is specified.</p> <pre><code>// Example: In the ReleaseBuilder API.\n// builder == ReleaseBuilder\nvar metadata = await builder.BuildAsync(new BuildArgs()\n{\n    FileName = \"Package\",\n    OutputFolder = this.OutputFolder,\n    PackageArchiver = new SevenZipSharpArchiver(new SevenZipSharpArchiverSettings()\n    {\n        CompressionLevel = CompressionLevel.Ultra,\n        ArchiveFormat = OutArchiveFormat.SevenZip,\n        CompressionMethod = CompressionMethod.Lzma2\n    })\n}\n</code></pre>"},{"location":"archivers/sharpcompress/","title":"SharpCompress","text":""},{"location":"archivers/sharpcompress/#sharpcompress-archiver","title":"SharpCompress Archiver","text":"<p>[Found In: <code>Sewer56.Update.Extractors.SharpCompress</code>]  </p> <p>The <code>SharpCompress Archiver</code> can be used to extract or archive packages using various container formats and compression algorithms.</p> <p>The implementation is actively tested with the following containers: - Zip - Tar  </p> <p>And the following compression formats: - Deflate - BZip2 - LZMA - PPMd  </p> <p>Other formats supported by the library should however still work.</p> <p>Full list of formats.</p>"},{"location":"archivers/sharpcompress/#example-usage-extract","title":"Example Usage (Extract)","text":"<pre><code>// Example: In the UpdateManager API.\nawait UpdateManager&lt;Empty&gt;.CreateAsync(dummyUpdatee, new LocalPackageResolver(this.OutputFolder), new ZipPackageExtractor());\n</code></pre>"},{"location":"archivers/sharpcompress/#example-usage-compress","title":"Example Usage (Compress)","text":"<p>Note: This is the default archiver and will be used if none is specified.</p> <pre><code>// Example: In the ReleaseBuilder API.\n// builder == ReleaseBuilder\nvar metadata = await builder.BuildAsync(new BuildArgs()\n{\n    FileName = \"Package\",\n    OutputFolder = this.OutputFolder,\n    PackageArchiver = new ZipPackageCompressor() // &lt;=======\n}\n</code></pre>"},{"location":"archivers/zip-package/","title":"Zip Package","text":""},{"location":"archivers/zip-package/#zip-package-archiver","title":"Zip Package Archiver","text":"<p>The <code>Zip Package Archiver</code> can be used to extract or archive packages using the zip container and the DEFLATE algorithm.</p>"},{"location":"archivers/zip-package/#example-usage-extract","title":"Example Usage (Extract)","text":"<pre><code>// Example: In the UpdateManager API.\nawait UpdateManager&lt;Empty&gt;.CreateAsync(dummyUpdatee, new LocalPackageResolver(this.OutputFolder), new ZipPackageExtractor());\n</code></pre>"},{"location":"archivers/zip-package/#example-usage-compress","title":"Example Usage (Compress)","text":"<p>Note: This is the default archiver and will be used if none is specified.</p> <pre><code>// Example: In the ReleaseBuilder API.\n// builder == ReleaseBuilder\nvar metadata = await builder.BuildAsync(new BuildArgs()\n{\n    FileName = \"Package\",\n    OutputFolder = this.OutputFolder,\n    PackageCompressor = new ZipPackageCompressor() // &lt;=======\n}\n</code></pre>"},{"location":"extensibility/package-archivers/","title":"Custom Archivers","text":""},{"location":"extensibility/package-archivers/#package-compressors","title":"Package Compressors","text":"<p>You can add support for creating releases with custom archive formats by extending the <code>IPackageArchiver</code> interface, which is defined as:</p> <pre><code>/// &lt;summary&gt;\n/// Provider for archiving packages.\n/// &lt;/summary&gt;\npublic interface IPackageArchiver\n{\n    /// &lt;summary&gt;\n    /// Extracts contents of the given package to the given output directory.\n    /// &lt;/summary&gt;\n    /// &lt;param name=\"relativeFilePaths\"&gt;List of relative paths of files to compress.&lt;/param&gt;\n    /// &lt;param name=\"baseDirectory\"&gt;The base directory to which these paths are relative to.&lt;/param&gt;\n    /// &lt;param name=\"destPath\"&gt;The path where to save the package.&lt;/param&gt;\n    /// &lt;param name=\"progress\"&gt;Reports progress back.&lt;/param&gt;\n    /// &lt;param name=\"cancellationToken\"&gt;Can be used to cancel the operation.&lt;/param&gt;\n    Task CreateArchiveAsync(List&lt;string&gt; relativeFilePaths, string baseDirectory, string destPath, IProgress&lt;double&gt;? progress = null, CancellationToken cancellationToken = default);\n}\n</code></pre>"},{"location":"extensibility/package-archivers/#example","title":"Example","text":"<pre><code>/// &lt;summary&gt;\n/// Compresses packages into a zip file using the DEFLATE compression algorithm.\n/// &lt;/summary&gt;\npublic class ZipPackageArchiver : IPackageArchiver\n{\n    /// &lt;inheritdoc /&gt;\n    public async Task CompressPackageAsync(List&lt;string&gt; relativeFilePaths, string baseDirectory, string destPath, IProgress&lt;double&gt;? progress = null, CancellationToken cancellationToken = default)\n    {\n        await using var zipStream = new FileStream(destPath, FileMode.Create);\n        using var zipFile         = new ZipArchive(zipStream, ZipArchiveMode.Update);\n        var progressSlicer        = new ProgressSlicer(progress);\n\n        for (var x = 0; x &lt; relativeFilePaths.Count; x++)\n        {\n            var progressForFile = progressSlicer.Slice((float)x / relativeFilePaths.Count);\n            var relativePath    = relativeFilePaths[x];\n\n            var entry = zipFile.CreateEntry(relativePath, CompressionLevel.Optimal);\n            await using var sourceStream = File.Open(Paths.AppendRelativePath(relativePath, baseDirectory), FileMode.Open, FileAccess.Read);\n            await using var entryStream  = entry.Open();\n\n            await sourceStream.CopyToAsyncEx(entryStream, 65536, progressForFile, cancellationToken);\n        }\n\n        progress?.Report(1);\n    }\n}\n</code></pre>"},{"location":"extensibility/package-archivers/#usage","title":"Usage","text":"<p>Specify <code>IPackageArchiver</code> in <code>BuildArgs</code> when creating a new release with <code>ReleaseBuilder</code>.</p> <pre><code>var metadata = await builder.BuildAsync(new BuildArgs()\n{\n    FileName = \"Package\",\n    OutputFolder = this.OutputFolder,\n    PackageCompressor = new ZipPackageArchiver()\n});\n</code></pre>"},{"location":"extensibility/package-custom-metadata/","title":"Extra Package Metadata","text":""},{"location":"extensibility/package-custom-metadata/#custom-package-metadata","title":"Custom Package Metadata","text":"<p>It is possible to specify custom metadata to apply to packages.  Many APIs, such as <code>ReleaseBuilder</code> have a generic <code>&lt;T&gt;</code> type that can be used for holding additional data.</p> <p>This additional data is used in tandem with APIs which add items, such as <code>ReleaseBuilder&lt;T&gt;.AddCopyPackage()</code>.</p>"},{"location":"extensibility/package-custom-metadata/#building-a-package-with-custom-metadata","title":"Building a Package with Custom Metadata","text":"<p>Consider the following snippet using <code>ReleaseBuilder&lt;T&gt;</code>.</p> <pre><code>var builder = new ReleaseBuilder&lt;string&gt;();\nbuilder.AddCopyPackage(new CopyBuilderItem&lt;Empty&gt;()\n{\n    FolderPath = Assets.ManyFileFolderOriginal,\n    Version = \"1.0\",\n    Data = \"This is a string attached to an individual release package.\" // &lt;= Custom Data\n});\n</code></pre>"},{"location":"extensibility/package-custom-metadata/#reading-custom-metadata-from-package","title":"Reading Custom Metadata from Package","text":"<p>If you are handling the intermediate update steps manually, you can get custom package metadata as soon as the update has been prepared.</p> <p>Consider a situation where you are handling the intermediate steps manually:</p> <pre><code>var result = await manager.CheckForUpdatesAsync();\nif (result.CanUpdate)\n{\n    // Downloads and extracts the package in the background\n    // (supports progress reporting and cancellation)\n    await manager.PrepareUpdateAsync(result.LastVersion);\n\n    // Get the metadata from the package.\n    var packageMetadata = await updateManager.TryGetPackageMetadataAsync(result.LastVersion);\n}\n</code></pre>"},{"location":"extensibility/package-extractors/","title":"Custom Extractors","text":""},{"location":"extensibility/package-extractors/#package-extractors","title":"Package Extractors","text":"<p>You can add support for custom archive formats by extending the <code>IPackageExtractor</code> interface, which is defined as:</p> <pre><code>/// &lt;summary&gt;\n/// Provider for extracting packages.\n/// &lt;/summary&gt;\npublic interface IPackageExtractor\n{\n    /// &lt;summary&gt;\n    /// Extracts contents of the given package to the given output directory.\n    /// &lt;/summary&gt;\n    Task ExtractPackageAsync(string sourceFilePath, string destDirPath, IProgress&lt;double&gt;? progress = null, CancellationToken cancellationToken = default);\n}\n</code></pre>"},{"location":"extensibility/package-extractors/#example","title":"Example","text":"<pre><code>/// &lt;summary&gt;\n/// Extracts files from zip-archived packages.\n/// &lt;/summary&gt;\npublic class ZipPackageExtractor : IPackageExtractor\n{\n    /// &lt;inheritdoc /&gt;\n    public async Task ExtractPackageAsync(string sourceFilePath, string destDirPath, IProgress&lt;double&gt;? progress = null, CancellationToken cancellationToken = default)\n    {\n        // Read the zip\n        using var archive = ZipFile.OpenRead(sourceFilePath);\n\n        // For progress reporting\n        var totalBytes = archive.Entries.Sum(e =&gt; e.Length);\n        var totalBytesCopied = 0L;\n\n        // Loop through all entries\n        foreach (var entry in archive.Entries)\n        {\n            // Get destination paths\n            var entryDestFilePath = Path.Combine(destDirPath, entry.FullName);\n            var entryDestDirPath  = Path.GetDirectoryName(entryDestFilePath);\n\n            // Create directory\n            if (!string.IsNullOrWhiteSpace(entryDestDirPath))\n                Directory.CreateDirectory(entryDestDirPath);\n\n            // If the entry is a directory - continue\n            if (entry.FullName.Last() == Path.DirectorySeparatorChar || entry.FullName.Last() == Path.AltDirectorySeparatorChar)\n                continue;\n\n            // Extract entry\n            await using var input  = entry.Open();\n            await using var output = File.Create(entryDestFilePath);\n            using var buffer = new ArrayRental&lt;byte&gt;(65536);\n\n            int bytesCopied;\n            do\n            {\n                bytesCopied = await input.CopyBufferedToAsync(output, buffer.Array, cancellationToken);\n                totalBytesCopied += bytesCopied;\n                progress?.Report(1.0 * totalBytesCopied / totalBytes);\n            } \n            while (bytesCopied &gt; 0);\n        }\n    }\n}\n</code></pre>"},{"location":"extensibility/package-extractors/#usage","title":"Usage","text":"<p>Use your new package resolver class when creating the update manager, as such:</p> <pre><code>// Create an update manager that updates from filesystem `LocalPackageResolver` and stores packages as zips `ZipPackageExtractor`.\nusing var manager = await UpdateManager&lt;Empty&gt;.CreateAsync(updatee, new LocalPackageResolver(\"c:\\\\test\\\\release\"), new ZipPackageExtractor());\n</code></pre>"},{"location":"extensibility/package-resolvers/","title":"Custom Download Sources","text":""},{"location":"extensibility/package-resolvers/#package-resolvers","title":"Package Resolvers","text":"<p>You can add support for downloading releases from custom sources by extending the <code>IPackageResolver</code> interface, which is defined as:</p> <pre><code>/// &lt;summary&gt;\n/// Provider for resolving packages.\n/// &lt;/summary&gt;\npublic interface IPackageResolver\n{\n    /// &lt;summary&gt;\n    /// Called only once.\n    /// \n    /// Use this for performing any asynchronous initialization (that you cannot do in the constructor) such as\n    /// - Reading from cache.\n    /// - Fetching release metadata.\n    /// - Fetching resources from a remote server.\n    /// Use this for any asynchronous operations that would be required in your constructor.\n    /// &lt;/summary&gt;\n    Task InitializeAsync() { return Task.CompletedTask; }\n\n    /// &lt;summary&gt;\n    /// Returns all available package versions.\n    /// &lt;/summary&gt;\n    /// &lt;remarks&gt;\n    ///     If you have release metadata, available consider using &lt;see cref=\"NuGetExtensions.GetNuGetVersionsFromReleaseMetadata(ReleaseMetadata)\"/&gt;.\n    ///     If the source provides its own release system with versions (e.g. GitHub API), use the versions returned from the API call.\n    /// &lt;/remarks&gt;\n    Task&lt;List&lt;NuGetVersion&gt;&gt; GetPackageVersionsAsync(CancellationToken cancellationToken = default);\n\n    /// &lt;summary&gt;\n    /// Downloads given package version.\n    /// &lt;/summary&gt;\n    /// &lt;remarks&gt;\n    ///     If source uses its own release system e.g. GitHub, download the release metadata here first.\n    ///     Pass &lt;see cref=\"ReleaseMetadataVerificationInfo\"/&gt; to &lt;see cref=\"ReleaseMetadata.GetRelease\"/&gt;.\n    ///     Get file name from returned item, and download using that file name.\n    /// &lt;/remarks&gt;\n    /// &lt;param name=\"progress\"&gt;Reports progress about the package download.&lt;/param&gt;\n    /// &lt;param name=\"cancellationToken\"&gt;Allows for cancellation of the operation.&lt;/param&gt;\n    /// &lt;param name=\"version\"&gt;The version to be downloaded.&lt;/param&gt;\n    /// &lt;param name=\"destFilePath\"&gt;File path where the item should be downloaded to.&lt;/param&gt;\n    /// &lt;param name=\"verificationInfo\"&gt;\n    ///     Pass this to &lt;see cref=\"ReleaseMetadata.GetRelease\"/&gt;.\n    ///     This is the information required to verify whether some package types, e.g. Delta Packages can be applied.\n    /// &lt;/param&gt;\n    Task DownloadPackageAsync(NuGetVersion version, string destFilePath, ReleaseMetadataVerificationInfo verificationInfo, IProgress&lt;double&gt;? progress = null, CancellationToken cancellationToken = default);\n}\n</code></pre>"},{"location":"extensibility/package-resolvers/#example","title":"Example","text":"<pre><code>/// &lt;summary&gt;\n/// Resolves packages from a local folder.\n/// Local folder must contain manifest for each package.\n/// &lt;/summary&gt;\npublic class LocalPackageResolver : IPackageResolver\n{\n    private ReleaseMetadata? _releases;\n    private string _repositoryFolder;\n\n    /// &lt;summary/&gt;\n    /// &lt;param name=\"repositoryFolder\"&gt;Folder containing packages and package manifest.&lt;/param&gt;\n    public LocalPackageResolver(string repositoryFolder)\n    {\n        _repositoryFolder = repositoryFolder;\n    }\n\n    /// &lt;inheritdoc /&gt;\n    public async Task InitializeAsync() =&gt; _releases = await Singleton&lt;ReleaseMetadata&gt;.Instance.ReadFromDirectoryAsync(_repositoryFolder);\n\n    /// &lt;inheritdoc /&gt;\n    public Task&lt;List&lt;NuGetVersion&gt;&gt; GetPackageVersionsAsync(CancellationToken cancellationToken = default) =&gt; Task.FromResult(_releases!.GetNuGetVersionsFromReleaseMetadata());\n\n    /// &lt;inheritdoc /&gt;\n    public async Task DownloadPackageAsync(NuGetVersion version, string destFilePath, ReleaseMetadataVerificationInfo verificationInfo, IProgress&lt;double&gt;? progress = null, CancellationToken cancellationToken = default)\n    {\n        var releaseItem = _releases!.GetRelease(version.ToString(), verificationInfo);\n        await using var sourceFile = File.Open(Path.Combine(_repositoryFolder, releaseItem!.FileName), FileMode.Open);\n        await using var targetFile = File.Open(destFilePath, FileMode.Create);\n        await sourceFile.CopyToAsyncEx(targetFile, 65536, progress, cancellationToken);\n    }\n}\n</code></pre> <p>The following implementation would allow you to download packages from a local folder on your machine.</p>"},{"location":"extensibility/package-resolvers/#usage","title":"Usage","text":"<p>Use your new package resolver class when creating the update manager, as such:</p> <pre><code>// Create an update manager that updates from filesystem `LocalPackageResolver` and stores packages as zips `ZipPackageExtractor`.\nusing var manager = await UpdateManager&lt;Empty&gt;.CreateAsync(updatee, new LocalPackageResolver(\"c:\\\\test\\\\release\"), new ZipPackageExtractor());\n</code></pre>"},{"location":"extensibility/package-resolvers/#extensions","title":"Extensions","text":"<p>Some resolvers may support additional (optional) extensions such as <code>IPackageResolverDownloadSize</code> which allows you to get the download size of a package before downloading it.  </p> <p>Example usage: <pre><code>// Get file size (if supported)\nif (resolver is IPackageResolverDownloadSize downloadSizeProvider)\n    fileSize = await downloadSizeProvider.GetDownloadFileSizeAsync(version, verificationInfo, token);\n</code></pre></p> <p>Available Extensions:  </p> Type Description IPackageResolverDownloadSize Returns the size of the package to be downloaded. IPackageResolverDownloadUrl Returns direct download URL for the package. IPackageResolverGetReleaseMetadata Retrieves the release metadata file."},{"location":"resolvers/aggregate-package-resolver/","title":"Aggregate Package Resolver","text":""},{"location":"resolvers/aggregate-package-resolver/#aggregate-package-resolver","title":"Aggregate Package Resolver","text":"<p>The <code>Aggregate Package Resolver</code> obtains releases from a collection of other, external package resolvers. The priority of the resolvers is based on their list order from first (highest) to last (lowest) priority.</p>"},{"location":"resolvers/aggregate-package-resolver/#example-usage","title":"Example Usage","text":"<pre><code>// Add 2 package resolvers to the aggregate resolver.\nvar resolver = new AggregatePackageResolver(new List&lt;IPackageResolver&gt;()\n{\n    new GameBananaUpdateResolver(GameBananaConfig, commonResolverSettings), // Higher Priority\n    new GitHubReleaseResolver(GitHubConfig, commonResolverSettings),        // Lower Priority\n});\n\nawait resolver.InitializeAsync();\nvar versions = await resolver.GetPackageVersionsAsync();\n\n// etc.\n</code></pre>"},{"location":"resolvers/gamebanana-package-resolver/","title":"GameBanana Package Resolver","text":""},{"location":"resolvers/gamebanana-package-resolver/#gamebanana-package-resolver","title":"GameBanana Package Resolver","text":"<p>[Found In: <code>Sewer56.Update.Resolvers.GameBanana</code>]  </p> <p>The <code>GameBanana Package Resolver</code> obtains releases from a GameBanana Mod page.</p>"},{"location":"resolvers/gamebanana-package-resolver/#example-usage","title":"Example Usage","text":""},{"location":"resolvers/gamebanana-package-resolver/#receiving-updates","title":"Receiving Updates","text":"<pre><code>// Use GameBanana Package Resolver with a specified Repo as Config\nvar resolver = new GameBananaUpdateResolver(new GameBananaResolverConfiguration()\n{\n    ItemId = 333681 // Taken from URL, e.g. https://gamebanana.com/mods/333681\n});\n\nawait resolver.InitializeAsync();\nvar versions = await resolver.GetPackageVersionsAsync();\nawait resolver.DownloadPackageAsync(versions[0], packageFilePath, new ReleaseMetadataVerificationInfo() { FolderPath = this.OutputFolder });\n</code></pre>"},{"location":"resolvers/gamebanana-package-resolver/#release-building","title":"Release Building","text":"<pre><code>var metadata = await builder.BuildAsync(new BuildArgs()\n{\n    FileName = \"Package\",\n    OutputFolder = this.OutputFolder,\n    FileNameFilter = GameBananaUtilities.SanitizeFileName\n});\n</code></pre> <p>You must use the file name sanitizer <code>GameBananaUtilities.SanitizeFileName</code> when building releases to be uploading to GameBanana. Not doing so risks GameBanana trimming the end of the file names, making the updater not able to pick out the correct package to update from.</p>"},{"location":"resolvers/gamebanana-package-resolver/#about-this-implementation","title":"About this Implementation","text":"<p>This implementation is a bit quirky especially due issues with file names specific to GameBanana. GameBanana uses a set of rules for file names, which can be are pretty challenging to work with.</p>"},{"location":"resolvers/gamebanana-package-resolver/#file-name-length","title":"File Name Length","text":"<p>GameBanana currently has a 100 character limit for file names (+ extension). Before 08 Nov 2021, it was a 40 character limit, which was tough!. </p>"},{"location":"resolvers/gamebanana-package-resolver/#file-name-deduplication","title":"File Name Deduplication","text":"<p>If a file with a given name has been uploaded prior, the file name will has a 6 character string appended to the end to make it unique.  If the resulting string is too long, characters will be cut from the original string.</p> <p>Any file name with over 94 characters risks the loss of version number from its name, making the resolver unable to determine the correct package to update from.</p> <p>As such. package names, including version information and extension must be limited to 94 characters max.</p>"},{"location":"resolvers/gamebanana-package-resolver/#file-name-character-set","title":"File Name Character Set","text":"<p>GameBanana only supports lowercase AlphaNumeric characters, underscores <code>_</code> and dashes <code>-</code> in file names.</p>"},{"location":"resolvers/gamebanana-package-resolver/#file-format-allowance","title":"File Format Allowance","text":"<p>GameBanana does not allow you to upload non archive formats (e.g. <code>.json</code>). Release metadata has to be wrapped in a dummy <code>zip</code> archive, which often is wasteful as it will result in a larger file size. (e.g. 304 bytes instead of 237 bytes)</p>"},{"location":"resolvers/github-release-resolver/","title":"GitHub Release Resolver","text":""},{"location":"resolvers/github-release-resolver/#github-release-resolver","title":"GitHub Release Resolver","text":"<p>[Found In: <code>Sewer56.Update.Resolvers.GitHub</code>]  </p> <p>The <code>GitHub Release Resolver</code> reads releases from a given repository's Releases section.</p>"},{"location":"resolvers/github-release-resolver/#example-usage","title":"Example Usage","text":"<pre><code>// Use GitHub Package Resolver with a specified Repo as Config\nvar resolver = new GitHubReleaseResolver(new GitHubResolverConfiguration()\n{\n    UserName       = \"Sewer56\", \n    RepositoryName = \"Update.Test.Repo\"\n});\n\nvar versions = await resolver.GetPackageVersionsAsync();\nawait resolver.DownloadPackageAsync(versions[0], packageFilePath, new ReleaseMetadataVerificationInfo() { FolderPath = this.OutputFolder });\n</code></pre>"},{"location":"resolvers/github-release-resolver/#about-this-implementation","title":"About this Implementation","text":"<p>Example Repository: https://github.com/Sewer56/Update.Test.Repo/releases</p> <p></p> <p>This implementation fetches releases by using the GitHub API, and has two modes of operation, one which uses versions from the release tag (default) and one which uses the files uploaded in the latest GitHub Release.</p>"},{"location":"resolvers/github-release-resolver/#version-from-tag-default","title":"Version from Tag (Default)","text":"<p>Use case: When there is only 1 package/download per repository.  </p> <p>In this mode, tags are used to denote release versions. If you tag your release with 1.1, the returned version will be 1.1.  </p> <p>Releases should consist of only the packages with the same version as the tag they are under. If you have a release with version 1.1, you should only include the following packages in the release:  </p> <ul> <li>Regular (Copy) Package with Version 1.1  </li> <li>Delta Package from $(PreviousVersion) to 1.1 [Optional]  </li> </ul>"},{"location":"resolvers/github-release-resolver/#version-from-metadata-file","title":"Version from Metadata File","text":"<p>Use case: When there are multiple packages/downloads per repository.  </p> <p>This one works like all the other resolvers. Simply upload all of the files to the latest release (or pre-release).  </p>"},{"location":"resolvers/github-release-resolver/#caching","title":"Caching","text":"<p>This implementation in particular uses some very aggressive API call saving tactics to avoid hitting the  rate limit (60 per hour per IP!!), at the expense of bringing in additional dependencies.</p>"},{"location":"resolvers/github-release-resolver/#response-caching","title":"Response Caching","text":"<p>This implementation uses Conditional Requests (ETags) to cache responses from the GitHub API such that they don't count against the rate limit.  </p> <p>Specifically it uses the CacheCow library to provide support for RFC 7230 and RFC 2616 HTTP caching headers in conjunction with Akavache, used to provide the backing storage for cached items.</p> <p>More specifically, a map of all received ETags to their respective responses is stored in a local SQLite3.X database.  This database is...  - Located in <code>$\"AppData/Local/Sewer56.Update.Resolvers.GitHub/Cache.db\"</code> (or your platform equivalent). - Shared between all library instances. - Thread safe.  </p> <p>Items have an expiration date of 30 days. </p>"},{"location":"resolvers/local-package-resolver/","title":"Local Package Resolver","text":""},{"location":"resolvers/local-package-resolver/#local-package-resolver","title":"Local Package Resolver","text":"<p>The <code>Local Package Resolver</code> reads releases from a local directory on your machine.</p>"},{"location":"resolvers/local-package-resolver/#example-usage","title":"Example Usage","text":"<pre><code>// Use Local Package Resolver\nvar resolver = new LocalPackageResolver(OutputFolder);\nawait resolver.InitializeAsync();\nvar versions = await resolver.GetPackageVersionsAsync();\n</code></pre>"},{"location":"resolvers/nuget-package-resolver/","title":"NuGet Package Resolver","text":""},{"location":"resolvers/nuget-package-resolver/#nuget-package-resolver","title":"NuGet Package Resolver","text":"<p>[Found In: <code>Sewer56.Update.Resolvers.NuGet</code>]  </p> <p>The <code>NuGet Package Resolver</code> obtains releases from a NuGet V3 Feed.  </p> <p>Note: The NuGet implementation does not support delta updates. </p>"},{"location":"resolvers/nuget-package-resolver/#example-usage","title":"Example Usage","text":""},{"location":"resolvers/nuget-package-resolver/#receiving-updates","title":"Receiving Updates","text":"<pre><code>var resolver = new NuGetUpdateResolver(new NuGetUpdateResolverSettings()\n{\n    NugetRepository = new NugetRepository(\"https://api.nuget.org/v3/index.json\"), // Index URL\n    PackageId = \"Totally.Not.Newtonsoft.Json\" // Package ID\n});\n\nvar versions = await resolver.GetPackageVersionsAsync();\nawait resolver.DownloadPackageAsync(versions[0], packageFilePath, new ReleaseMetadataVerificationInfo() { FolderPath = this.OutputFolder });\n</code></pre>"}]}